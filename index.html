<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>django signal</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">

    <style>
        .reveal h1 {
            text-transform: none;
        }
        .reveal h3 {
            text-transform: none;
        }
    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section><h1>Signals In Django</h1><a href="https://docs.djangoproject.com/en/5.0/topics/signals/">doc</a></section>
        <section data-visibility="hidden">
            <h3>Outline</h3>
            <ul>
                <li></li>
                <li></li>
                <li></li>
            </ul>
        </section>
        <section>
            <h3>Signals</h3>
            <p>Django includes a “signal dispatcher” which helps decoupled applications get notified when actions occur elsewhere in the framework.</p>
            <p>In a nutshell, <u>signals allow certain senders to notify a set of receivers that some action has taken
                place</u>. They’re especially useful when many pieces of code may be interested in the same events.</p>
        </section>
        <section>
            <h3>Warning</h3>
            <p>Signals give the appearance of loose coupling, but they can quickly lead to code that is hard to understand, adjust and debug.</p>
                <p>Where possible you should opt for directly calling the handling code, rather than dispatching via a signal.</p>
        </section>
        <section>
            <h3>Listening to signals</h3>
            <p>To receive a signal, register a receiver function using the Signal.connect() <a href="https://docs.djangoproject.com/en/5.0/topics/signals/#django.dispatch.Signal.connect" target="_blank">method</a>.</p>
            <p>The receiver function is called when the signal is sent. All of the signal’s receiver functions are called one at a time, in the order they were registered.</p>
        </section>
        <section>
            <section>
                <h1>Receiver functions</h1>
                <p>First, we need to define a receiver function. A receiver can be any Python function or method:</p>
                <pre><code>def my_callback(sender, **kwargs):
    print("Request finished!")</code></pre>
            </section>
            <section>
                <p>Notice that the function takes a sender argument, along with wildcard keyword arguments (**kwargs); all signal handlers must take these arguments.</p>
            </section>
            <section>
                <p>Receivers may also be asynchronous functions, with the same signature but declared using async def:</p>
                <pre><code>async def my_callback(sender, **kwargs):
    await asyncio.sleep(5)
    print("Request finished!")</code></pre>
            </section>
            <section>
                <p>Signals can be sent either synchronously or asynchronously, and receivers will automatically be adapted to the correct call-style.</p>
            </section>
        </section>
        <section>
            <section>
                <h1>Connecting receiver functions</h1>
                <p>There are two ways you can connect a receiver to a signal. You can take the manual connect route:</p>
            </section>
            <section>
                <pre><code>from django.core.signals import request_finished
request_finished.connect(my_callback)</code></pre>
            </section>
            <section>
                <p>Alternatively, you can use a receiver() <a href="https://docs.djangoproject.com/en/5.0/topics/signals/#django.dispatch.receiver" target="_blank">decorator</a>:</p>
                <pre><code>from django.core.signals import request_finished
from django.dispatch import receiver


@receiver(request_finished)
def my_callback(sender, **kwargs):
    print("Request finished!")</code></pre>
                <p>Now, our my_callback function will be called each time a request finishes.</p>
            </section>
            <section>
                <h3>Where should this code live?</h3>
            </section>
            <section>
                <p>Strictly speaking, signal handling and registration code can live anywhere you like, ...</p>
            </section>
            <section>
                <p>In practice, signal handlers are usually defined in a <u>signals submodule</u> of the application they relate to.</p>
                <p>Signal receivers are connected in the ready() method of your application configuration class.</p>
                <p>If you’re using the receiver() decorator, import the signals submodule inside ready(), this will implicitly connect signal handlers:</p>
            </section>
            <section>
                <pre><code>from django.apps import AppConfig
from django.core.signals import request_finished


class MyAppConfig(AppConfig):
    ...

    def ready(self):
        # Implicitly connect signal handlers decorated with @receiver.
        from . import signals

        # Explicitly connect a signal handler.
        request_finished.connect(signals.my_callback)</code></pre>
            </section>
        </section>
        <section>
            <section>Connecting to signals sent by specific senders</section>
            <section>
                <p>Some signals get sent many times, but you’ll only be interested in receiving a certain subset of those signals.</p>
                <p>For example, consider the django.db.models.signals.pre_save signal sent before a model gets saved. </p>
                <p>Most of the time, you don’t need to know when any model gets saved – just when one specific model is saved.</p>
            </section>
            <section>
                <p>In these cases, you can register to receive signals sent only by particular senders.</p>
                <pre><code>from django.db.models.signals import pre_save
from django.dispatch import receiver
from myapp.models import MyModel


@receiver(pre_save, sender=MyModel)
def my_handler(sender, **kwargs): ...</code></pre>
            </section>
        </section>
        <section>
            <section>
                <h3>Preventing duplicate signals</h3>
                <p>In some circumstances, the code connecting receivers to signals may run multiple times. ...</p>
                <p> More generally, this occurs everywhere your project imports the module where you define the signals, because signal registration runs as many times as it is imported.</p>
            </section>
            <section>
                <p>If this behavior is problematic (such as when using signals to send an email whenever a model is saved), pass a unique identifier as the dispatch_uid argument to identify your receiver function.</p>
                <p>This identifier will usually be a string, although any hashable object will suffice.</p>
            </section>
            <section>
                <p>The end result is that your receiver function will only be bound to the signal once for each unique dispatch_uid value:</p>
                <pre><code>from django.core.signals import request_finished

request_finished.connect(my_callback, dispatch_uid="my_unique_identifier")</code></pre>
            </section>
        </section>
        <section>
            <section>
                <h3>Defining and sending signals</h3>
            </section>
            <section>
                <p>Signals are implicit function calls which make debugging harder.</p>
                <p>If the sender and receiver of your custom signal are both within your project, you’re better off using an explicit function call.</p>
            </section>
        </section>
        <section>
            <section id="defining-signals">
                <h3>Defining signals</h3>
                <pre><code>import django.dispatch

pizza_done = django.dispatch.Signal()</code></pre>
            </section>
            <section>
                <h3>Sending signals</h3>
                <ul>
                    <li>Signal.send(sender, **kwargs)</li>
                    <li>Signal.send_robust(sender, **kwargs)</li>
                    <li>Signal.asend(sender, **kwargs)</li>
                    <li>Signal.asend_robust(sender, **kwargs)</li>
                </ul>
            </section>
            <section>
                <h3>Sending signals</h3>
                <pre><code>class PizzaStore:
    ...

    def send_pizza(self, toppings, size):
        pizza_done.send(sender=self.__class__, toppings=toppings, size=size)
        ...</code></pre>
            </section>
            <section>
                <p>All four methods return a list of tuple pairs [(receiver, response), ...], representing the list of called receiver functions and their response values.</p>
            </section>
            <section>
                <h3>send vs. send_robust</h3>
                <p>how exceptions raised by receiver functions are handled. send() does not catch any exceptions raised by receivers; it simply allows errors to propagate.</p>
                <p>Thus not all receivers may be notified of a signal in the face of an error.</p>
            </section>
            <section>
                <p>send_robust() catches all errors derived from Python’s Exception class, and ensures all receivers are notified of the signal. If an error occurs, the error instance is returned in the tuple pair for the receiver that raised the error.</p>
                <p>The tracebacks are present on the __traceback__ attribute of the errors returned when calling send_robust().</p>
                <p>asend vs send ... </p>
            </section>
        </section>
        <section>
            <section>
                <h3>Disconnecting signals</h3>
                <pre><code>Signal.disconnect(receiver=None, sender=None, dispatch_uid=None)</code></pre>
                <p>... The receiver argument indicates the registered receiver to disconnect. It may be None if dispatch_uid is used to identify the receiver.</p>
            </section>
        </section>
        <section>
            <section><h3>Demo</h3><a href="https://www.geeksforgeeks.org/how-to-create-and-use-signals-in-django/">gfg</a></section>
            <section>
                <h3>Model Signals</h3>
                <ul>
                    <li>pre_save/post_save: This signal works before/after the method save().</li>
                    <li>pre_delete/post_delete: This signal works before after deleting a model’s instance (method delete()) this signal is thrown.</li>
                    <li>pre_init/post_init: This signal is thrown before/after instantiating a model (__init__() method).</li>
                </ul>
            </section>
        </section>
        <section>
            <section>
                <h3>Short Summary - Django Signal</h3>
                <p><u>Sender</u>(part of application) wants to notify <u>Receiver</u></p>
            </section>
            <section>
                <h3>Signal samples in django: </h3>
                <ul>
                    <li class="fragment">model signals: pre_save, pre_delete, <a href="https://docs.djangoproject.com/en/5.1/ref/signals/#post-save">post_save</a></li>
                    <li class="fragment">request signals: request_started, request_finished</li>
                    <li class="fragment fade-up"><a href="https://docs.djangoproject.com/en/5.0/ref/signals/">list of django signals by default</a></li>
                </ul>
            </section>
            <section>
                <p>you should write your receiver in <code>signals.py</code></p>
                <pre><code>from django.core.signals import request_finished
from django.dispatch import receiver


@receiver(request_finished)
def my_callback(sender, **kwargs):
    print("Request finished!")</code></pre>
            </section>
            <section>
                <p>you can use decorator like line 5</p>
                <pre><code data-line-numbers>from django.core.signals import request_finished
from django.dispatch import receiver


@receiver(request_finished)
def my_callback(sender, **kwargs):
    print("Request finished!")
                </code></pre>
            </section>
            <section>
                <p>or you can connect it with comment method in AppConfig file</p>
                <pre><code data-line-numbers>from django.apps import AppConfig
from django.core.signals import request_finished


class MyAppConfig(AppConfig):
    ...

    def ready(self):
        # Implicitly connect signal handlers decorated with @receiver.
        from . import signals

        # Explicitly connect a signal handler.
        request_finished.connect(signals.my_callback)</code></pre>
            </section>
            <section>
                <h3>Sending Customize Signals</h3>
                <pre><code>import django.dispatch

class PizzaStore:
    ...

    def send_pizza(self, toppings, size):
        pizza_done = django.dispatch.Signal()
        pizza_done.send(sender=self.__class__, toppings=toppings, size=size)
        ...</code></pre>
                <p><a href="#/defining-signals">slide link</a></p>
            </section>
        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ],
        slideNumber: 'c/t',
    });
</script>
</body>
</html>
